说实话，这个题的答案，我没看懂，应该是数学的问题......
题目：Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.

Example 1:

Input: num1 = "2", num2 = "3"
Output: "6"

Example 2:

Input: num1 = "123", num2 = "456"
Output: "56088"

Note:

    The length of both num1 and num2 is < 110.
    Both num1 and num2 contain only digits 0-9.
    Both num1 and num2 do not contain any leading zero, except the number 0 itself.
    You must not use any built-in BigInteger library or convert the inputs to integer directly.


参考答案：
方法一：做加法

如果 num1\textit{num}_1num1​ 和 num2\textit{num}_2num2​ 之一是 000，则直接将 000 作为结果返回即可。

如果 num1\textit{num}_1num1​ 和 num2\textit{num}_2num2​ 都不是 000，则可以通过模拟「竖式乘法」的方法计算乘积。从右往左遍历乘数，将乘数的每一位与被乘数相乘得到对应的结果，再将每次得到的结果累加。这道题中，被乘数是 num1\textit{num}_1num1​，乘数是 num2\textit{num}_2num2​。

需要注意的是，num2\textit{num}_2num2​ 除了最低位以外，其余的每一位的运算结果都需要补 000。

class Solution {
    public String multiply(String num1, String num2) {
        if (num1.equals("0") || num2.equals("0")) {
            return "0";
        }
        String ans = "0";
        int m = num1.length(), n = num2.length();
        for (int i = n - 1; i >= 0; i--) {
            StringBuffer curr = new StringBuffer();
            int add = 0;
            for (int j = n - 1; j > i; j--) {
                curr.append(0);
            }
            int y = num2.charAt(i) - '0';
            for (int j = m - 1; j >= 0; j--) {
                int x = num1.charAt(j) - '0';
                int product = x * y + add;
                curr.append(product % 10);
                add = product / 10;
            }
            if (add != 0) {
                curr.append(add % 10);
            }
            ans = addStrings(ans, curr.reverse().toString());
        }
        return ans;
    }

    public String addStrings(String num1, String num2) {
        int i = num1.length() - 1, j = num2.length() - 1, add = 0;
        StringBuffer ans = new StringBuffer();
        while (i >= 0 || j >= 0 || add != 0) {
            int x = i >= 0 ? num1.charAt(i) - '0' : 0;
            int y = j >= 0 ? num2.charAt(j) - '0' : 0;
            int result = x + y + add;
            ans.append(result % 10);
            add = result / 10;
            i--;
            j--;
        }
        ans.reverse();
        return ans.toString();
    }
}

复杂度分析

    时间复杂度：O(mn+n2)O(mn+n^2)O(mn+n2)，其中 mmm 和 nnn 分别是 num1\textit{num}_1num1​ 和 num2\textit{num}_2num2​ 的长度。需要从右往左遍历 num2\textit{num}_2num2​，对于 num2\textit{num}_2num2​ 的每一位，都需要和 num1\textit{num}_1num1​ 的每一位计算乘积，因此计算乘积的总次数是 mnmnmn。字符串相加操作共有 nnn 次，相加的字符串长度最长为 m+nm+nm+n，因此字符串相加的时间复杂度是 O(mn+n2)O(mn+n^2)O(mn+n2)。总时间复杂度是 O(mn+n2)O(mn+n^2)O(mn+n2)。

    空间复杂度：O(m+n)O(m+n)O(m+n)，其中 mmm 和 nnn 分别是 num1\textit{num}_1num1​ 和 num2\textit{num}_2num2​ 的长度。空间复杂度取决于存储中间状态的字符串，由于乘积的最大长度为 m+nm+nm+n，因此存储中间状态的字符串的长度不会超过 m+nm+nm+n。

方法二：做乘法

方法一的做法是从右往左遍历乘数，将乘数的每一位与被乘数相乘得到对应的结果，再将每次得到的结果累加，整个过程中涉及到较多字符串相加的操作。如果使用数组代替字符串存储结果，则可以减少对字符串的操作。

令 mmm 和 nnn 分别表示 num1\textit{num}_1num1​ 和 num2\textit{num}_2num2​ 的长度，并且它们均不为 000，则 num1\textit{num}_1num1​ 和 num2\textit{num}_2num2​ 的乘积的长度为 m+n−1m+n-1m+n−1 或 m+nm+nm+n。简单证明如下：

    如果 num1\textit{num}_1num1​ 和 num2\textit{num}_2num2​ 都取最小值，则 num1=10m−1\textit{num}_1=10^{m-1}num1​=10m−1，num2=10n−1\textit{num2}=10^{n-1}num2=10n−1，num1×num2=10m+n−2\textit{num}_1 \times \textit{num}_2=10^{m+n-2}num1​×num2​=10m+n−2，乘积的长度为 m+n−1m+n-1m+n−1；

    如果 num1\textit{num}_1num1​ 和 num2\textit{num}_2num2​ 都取最大值，则 num1=10m−1\textit{num}_1=10^m-1num1​=10m−1，num2=10n−1\textit{num}_2=10^n-1num2​=10n−1，num1×num2=10m+n−10m−10n+1\textit{num}_1 \times \textit{num}_2=10^{m+n}-10^m-10^n+1num1​×num2​=10m+n−10m−10n+1，乘积显然小于 10m+n10^{m+n}10m+n 且大于 10m+n−110^{m+n-1}10m+n−1，因此乘积的长度为 m+nm+nm+n。

由于 num1\textit{num}_1num1​ 和 num2\textit{num}_2num2​ 的乘积的最大长度为 m+nm+nm+n，因此创建长度为 m+nm+nm+n 的数组 ansArr\textit{ansArr}ansArr 用于存储乘积。对于任意 0≤i<m0 \le i < m0≤i<m 和 0≤j<n0 \le j < n0≤j<n，num1[i]×num2[j]\textit{num}_1[i] \times \textit{num}_2[j]num1​[i]×num2​[j] 的结果位于 ansArr[i+j+1]\textit{ansArr}[i+j+1]ansArr[i+j+1]，如果 ansArr[i+j+1]≥10\textit{ansArr}[i+j+1] \ge 10ansArr[i+j+1]≥10，则将进位部分加到 ansArr[i+j]\textit{ansArr}[i+j]ansArr[i+j]。

最后，将数组 ansArr\textit{ansArr}ansArr 转成字符串，如果最高位是 000 则舍弃最高位。

class Solution {
    public String multiply(String num1, String num2) {
        if (num1.equals("0") || num2.equals("0")) {
            return "0";
        }
        int m = num1.length(), n = num2.length();
        int[] ansArr = new int[m + n];
        for (int i = m - 1; i >= 0; i--) {
            int x = num1.charAt(i) - '0';
            for (int j = n - 1; j >= 0; j--) {
                int y = num2.charAt(j) - '0';
                ansArr[i + j + 1] += x * y;
            }
        }
        for (int i = m + n - 1; i > 0; i--) {
            ansArr[i - 1] += ansArr[i] / 10;
            ansArr[i] %= 10;
        }
        int index = ansArr[0] == 0 ? 1 : 0;
        StringBuffer ans = new StringBuffer();
        while (index < m + n) {
            ans.append(ansArr[index]);
            index++;
        }
        return ans.toString();
    }
}

复杂度分析

    时间复杂度：O(mn)O(mn)O(mn)，其中 mmm 和 nnn 分别是 num1\textit{num}_1num1​ 和 num2\textit{num}_2num2​ 的长度。需要计算 num1\textit{num}_1num1​ 的每一位和 num2\textit{num}_2num2​ 的每一位的乘积。

    空间复杂度：O(m+n)O(m+n)O(m+n)，其中 mmm 和 nnn 分别是 num1\textit{num}_1num1​ 和 num2\textit{num}_2num2​ 的长度。需要创建一个长度为 m+nm+nm+n 的数组存储乘积。
