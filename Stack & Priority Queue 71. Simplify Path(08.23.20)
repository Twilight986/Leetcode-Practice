Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path.

In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level.

Note that the returned canonical path must always begin with a slash /, and there must be only a single slash / between two directory names. The last directory name (if it exists) must not end with a trailing /. Also, the canonical path must be the shortest string representing the absolute path.

 

Example 1:

Input: "/home/"
Output: "/home"
Explanation: Note that there is no trailing slash after the last directory name.

Example 2:

Input: "/../"
Output: "/"
Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.

Example 3:

Input: "/home//foo/"
Output: "/home/foo"
Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.

Example 4:

Input: "/a/./b/../../c/"
Output: "/c"

Example 5:

Input: "/a/../../b/../c//.//"
Output: "/c"

Example 6:

Input: "/a//b////c/d//././/.."
Output: "/a/b/c"


评价: medium

参考讲解
一、主要设计了五种状态：

    读到一个点
    读到两个点
    读到分隔符号
    读到普通字符串
    错误

每次读取一个字符，根据当前字符、及当前状态，决定下一步的状态应该是什么。

对于该题目，每个输入都是"/"开头的。所以对于任何输入，都从“读到分隔符”状态开始，进行状态的流转，
最后一趟读完之后，再判断一下末位状态，做一下收尾工作
代码

class Solution {
     public String simplifyPath(String path) {
        if (path == null || path.length() == 0) return path;
        if (path.charAt(0) != '/') throw new RuntimeException("invalid path.");
        Context context = new Context();
        //从读到分隔附开始
        State state = State.SEPRA;
        //状态流转
        for (int i = 1; i < path.length(); i++) {
            State next = state.next(path.charAt(i), context);
            if (next == State.ERROR) throw new RuntimeException("parse err.");
            state = next;
        }
        //收尾工作
        if (state == State.NAME) {
            context.flush();
        } else if (state == State.DOT2) {
            context.removeLast();
        }
        //组装结果
        List<String> validStrings = context.getValidStrings();
        if (validStrings.isEmpty()) return "/";
        StringBuilder builder = new StringBuilder();
        builder.append("/");
        for (int i = 0; i < validStrings.size(); i++) {
            builder.append(validStrings.get((i)));
            if (i + 1 < validStrings.size()) builder.append("/");
        }
        return builder.toString();

    }
    //有限状态机
    private enum State {
        DOT1("读到一个点") {
            @Override
            State next(char c, Context context) {
                if (c == '.') return DOT2;
                if (c == '/') return SEPRA;
                context.addChar('.');
                context.addChar(c);
                return NAME;
            }
        }, DOT2("读到两个点") {
            @Override
            State next(char c, Context context) {
                if (c == '/') {
                    context.removeLast();
                    return SEPRA;
                }
                //文件名，
                context.addChars(new char[]{'.', '.'});
                context.addChar(c);
                return NAME;
            }
        }, SEPRA("读到分隔符") {
            @Override
            State next(char c, Context context) {
                if (c == '/') return SEPRA;
                if (c == '.') return DOT1;
                context.addChar(c);
                return NAME;
            }
        }, NAME("读到普通字符串") {
            @Override
            State next(char c, Context context) {
                if (c == '/') {
                    context.flush();
                    return SEPRA;
                }
                context.addChar(c);
                return NAME;
            }
        }, ERROR("错误") {
            @Override
            State next(char c, Context context) {
                return ERROR;
            }
        };
        State(String desc) {
            this.desc = desc;
        }
        private String desc;
        abstract State next(char c, Context context);

    }

    //记录中间状态，上下文
    private static class Context {
        //存放合法的字符串，最后结果就用这个拼接
        private List<String> strings = new ArrayList<>();
        //字符缓冲区
        private StringBuilder buffer = new StringBuilder();

        public void addChar(char c) {
            buffer.append(c);
        }
        public void addChars(char[] chars) {
            for (char aChar : chars) buffer.append(aChar);
        }
        public void clear() {
            buffer = new StringBuilder();
        }
        public void removeLast() {
            if (strings.size() > 0)
                strings.remove(strings.size() - 1);
        }
        public void flush() {
            if (buffer.length() > 0) {
                strings.add(buffer.toString());
                clear();
            }
        }
        public List<String> getValidStrings() {
            return strings;
        }
    }
}

作者：wai-guo-rou-jia-mo
链接：https://leetcode-cn.com/problems/simplify-path/solution/yi-tang-bian-li-4msji-bai-96-by-wai-guo-rou-jia-mo/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

二、
class Solution {
    public String simplifyPath(String path) {
        Deque<String> stack = new LinkedList<>();
        for (String item : path.split("/")) {
            if (item.equals("..")) {
                if (!stack.isEmpty()) stack.pop();
            } else if (!item.isEmpty() && !item.equals(".")) stack.push(item);
        }
        String res = "";
        for (String d : stack) res = "/" + d + res;
        return res.isEmpty() ? "/" : res;  
    }
}

最后一部分逆序遍历，用StringBuilder，节省空间

Deque<String>stack=new LinkedList<>();
		for(String item:path.split("/")) {
			if(item.equals("..")) {
				if(!stack.isEmpty())
					stack.pop();
			}else if(!item.isEmpty() && !item.equals("."))
				stack.push(item);
		}
		StringBuilder builder=new StringBuilder();

		Iterator<String>iterator=stack.descendingIterator();
		while(iterator.hasNext()) {
			String str=iterator.next();
			builder.append("/"+str);
		}
		return builder.length()==0?"/":builder.toString();


作者：powcai
链接：https://leetcode-cn.com/problems/simplify-path/solution/zhan-by-powcai/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
