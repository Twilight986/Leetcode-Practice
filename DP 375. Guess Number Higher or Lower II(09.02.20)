We are playing the Guess Game. The game is as follows:

I pick a number from 1 to n. You have to guess which number I picked.

Every time you guess wrong, I'll tell you whether the number I picked is higher or lower.

However, when you guess a particular number x, and you guess wrong, you pay $x. You win the game when you guess the number I picked.

Example:

n = 10, I pick 8.

First round:  You guess 5, I tell you that it's higher. You pay $5.
Second round: You guess 7, I tell you that it's higher. You pay $7.
Third round:  You guess 9, I tell you that it's lower. You pay $9.

Game over. 8 is the number I picked.

You end up paying $5 + $7 + $9 = $21.

Given a particular n ≥ 1, find out how much money you need to have to guarantee a win.


我的答案：
class Solution {
    public int getMoneyAmount(int n) {
        int[][] dp = new int[n + 1][n + 1];
        for (int len = 2; len <= n;  len++){
            for (int i = 1; i <= n - len + 1; i++){
                int min = Integer.MAX_VALUE;
                for (int piv = i + (len - 1) / 2; piv < len + i - 1; piv++){
                    int res = piv + Math.max(dp[i][piv - 1], dp[piv + 1][len +i - 1]);
                    min = Math.min(min, res);
                }
                dp[i][len + i - 1] = min;
            }
        }
        return dp[1][n];
    }
}

评价：medium

参考讲解：
概要

给一个数字 nnn ，我们要用最优策略在 (1,n)(1, n)(1,n) 范围内考虑猜中数字的最坏情况。每次错误的尝试 iii 都会导致总开销增加 iii 。

比方说：

n=5
1 2 3 4 5

假设答案是 5 ，如果我们一开始猜 3 ，那么我们下一次肯定猜 4 ，最终总代价为 4+3=74+3=74+3=7 。

假设答案是 3 或者 1, ，我们一开始猜 4 ，下一次猜 2 ，那么总代价为 4+2=64+2=64+2=6 ，这是最小总代价。

n=8
1 2 3 4 5 6 7 8

这种情况下我们先猜 5 然后猜 7 。总开销为 5+7=125+7=125+7=12 。
如果我们先猜 4 。总开销为 4+5+7=164+5+7=164+5+7=16 。
解法
方法 1：暴力

首先，我们需要意识到我们在范围 (1,n)(1, n)(1,n) 中猜数字的时候，需要考虑最坏情况下的代价。也就是说要算每次都猜错的情况下的总体最大开销。

在暴力算法中，我们首先在 (1,n)(1, n)(1,n) 中任意挑选一个数字，假设它是个错误的猜测（最坏情况），我们需要用最小代价去猜到需要的数字。那么在一次尝试以后，答案要么在我们猜的数字的左边要么在右边，为了考虑最坏情况，我们需要考虑两者的较大值。因此，如果我们选择 iii 作为第一次尝试，总体最小代价是：

cost(1,n)=i+max⁡(cost(1,i−1),cost(i+1,n))\mathrm{cost}(1, n)=i + \max\big(\mathrm{cost}(1,i-1), \mathrm{cost}(i+1,n)\big) cost(1,n)=i+max(cost(1,i−1),cost(i+1,n))

对于左右两段，我们分别考虑在段内选择一个数，并重复上面的过程来求得最小开销。

使用如上方法，我们能求得从 iii 开始猜，猜到答案的最小代价。同样地，我们遍历 (1,n)(1, n)(1,n) 中的所有数字并分别作为第一次尝试，求出每一个的代价，并输入最小值即为答案。

public class Solution {
    public int calculate(int low, int high) {
        if (low >= high)
            return 0;
        int minres = Integer.MAX_VALUE;
        for (int i = low; i <= high; i++) {
            int res = i + Math.max(calculate(i + 1, high), calculate(low, i - 1));
            minres = Math.min(res, minres);
        }

        return minres;
    }
    public int getMoneyAmount(int n) {
        return calculate(1, n);
    }
}

复杂度分析

    时间复杂度： O(n!)O(n!)O(n!) 。我们选择一个数作为第一次尝试，然后递归中再选一个数，这样重复 nnn 次的时间代价为 O(n!)O(n!)O(n!) 。
    空间复杂度： O(n)O(n)O(n) 。 nnn 层递归的开销。

方法 2：修改后的暴力

算法

在暴力解中，对于范围 (i,j)(i, j)(i,j) 中的每一个数字，我们都需要分别考虑选为当前的第一个猜测的代价，然后再分别考虑左右两个区间内的代价。但一个重要的发现是如果我们从范围 (i,i+j2)\big( i,\frac{i+j}{2} \big)(i,2i+j​) 内选择数字作为第一次尝试，右边区间都比左边区间大，所以我们只需要从右边区间获取最大开销即可，因为它的开销肯定比左边区间的要大。为了减少这个开销，我们第一次尝试肯定从 (i+j2,j)\big(\frac{i+j}{2}, j\big)(2i+j​,j) 中进行选数。这样子，两个区间的开销会更接近且总体开销会更小。

所以，我们不需要从 iii 到 jjj 遍历每个数字，只需要从 i+j2\frac{i+j}{2}2i+j​ 到 jjj 遍历，且找到暴力解的最小开销即可。

public class Solution {
    public int calculate(int low, int high) {
        if (low >= high)
            return 0;
        int minres = Integer.MAX_VALUE;
        for (int i = (low + high) / 2; i <= high; i++) {
            int res = i + Math.max(calculate(i + 1, high), calculate(low, i - 1));
            minres = Math.min(res, minres);
        }
        return minres;
    }
    public int getMoneyAmount(int n) {
        return calculate(1, n);
    }
}

复杂度分析

    时间复杂度： O(n!)O(n!)O(n!) 。我们选择一个数作为当前第一次尝试，然后在递归中重复这个过程，总时间开销为 O(n!)O(n!)O(n!) 。
    空间复杂度： O(n)O(n)O(n) 。递归的深度为 nnn 。

方法 3： DP

算法

以 iii 为第一次尝试找到最小开销的过程可以被分解为找左右区间内最小开销的子问题。对于每个区间，我们重复问题拆分的过程，得到更多子问题，这启发我们可以用 DP 解决这个问题。

我们需要使用一个 dpdpdp 矩阵，其中 dp(i,j)dp(i, j)dp(i,j) 代表在 (i,j)(i, j)(i,j) 中最坏情况下最小开销的代价。现在我们只需要考虑如何求出这个 dpdpdp 数组。如果区间只剩下一个数 kkk ，那么猜中的代价永远为 0 ，因为我们区间里只剩下一个数字，也就是说，所有的 dp(k,k)dp(k, k)dp(k,k) 都初始化为 0 。然后，对于长度为 2 的区间，我们需要所有长度为 1 的区间的结果。由此我们可以看出，为了求出长度为 lenlenlen 区间的解，我们需要所有长度为 len−1len-1len−1 的解。因此我们按照区间长度从短到长求出 dpdpdp 数组。

现在，我们应该按照什么办法来求出 dpdpdp 矩阵呢？对于每个 dp(i,j)dp(i, j)dp(i,j) ，当前长度为 len=j−i+1len=j-i+1len=j−i+1 。我们遵照方法 1 中俄办法，依次挑选每个数字作为第一次尝试的答案，可以求出最小开销：

cost(i,j)=pivot+max⁡(cost(i,pivot−1),cost(pivot+1,n))\mathrm{cost}(i, j)=\mathrm{pivot} + \max\big(\mathrm{cost}(i,\mathrm{pivot}-1), \mathrm{cost}(\mathrm{pivot}+1,n)\big) cost(i,j)=pivot+max(cost(i,pivot−1),cost(pivot+1,n))

但是在计算开销的时候我们有一个便利之处，就是我们已经知道了小于 lenlenlen 长度 dpdpdp 数组的所有答案。因此 dp 方程式变成了：

dp(i,j)=min⁡pivots(i,j)[pivot+max⁡(dp(i,pivot−1),dp(pivot+1,n))]\mathrm{dp}(i, j) = \min_{\mathrm{pivots}(i, j)} \big[ \mathrm{pivot} + \max \big( \mathrm{dp}(i,\mathrm{pivot}-1) , \mathrm{dp}(\mathrm{pivot}+1,n) \big) \big] dp(i,j)=pivots(i,j)min​[pivot+max(dp(i,pivot−1),dp(pivot+1,n))]

其中 min⁡pivots(i,j)\min_{\mathrm{pivots}(i, j)}minpivots(i,j)​ 表示将 (i,j)(i, j)(i,j) 中的每个数作为第一个尝试的数。

下面的动画更好地说明了 n=5 的情况：

public class Solution {
    public int getMoneyAmount(int n) {
        int[][] dp = new int[n + 1][n + 1];
        for (int len = 2; len <= n; len++) {
            for (int start = 1; start <= n - len + 1; start++) {
                int minres = Integer.MAX_VALUE;
                for (int piv = start; piv < start + len - 1; piv++) {
                    int res = piv + Math.max(dp[start][piv - 1], dp[piv + 1][start + len - 1]);
                    minres = Math.min(res, minres);
                }
                dp[start][start + len - 1] = minres;
            }
        }
        return dp[1][n];
    }
}

复杂度分析

    时间复杂度： O(n3)O(n^3)O(n3) 。我们遍历 dpdpdp 数组一遍需要 O(n2)O(n^2)O(n2) 的时间开销。对于数组中每个元素，我们最多需要遍历 nnn 个数字。

    空间复杂度： O(n2)O(n^2)O(n2) 。需要创建 n2n^2n2 空间的 dpdpdp数组。

方法 4：优化的 DP

算法

在上一个方法中，我们尝试使用 (i,j)(i, j)(i,j) 中的每一个数作为第一个选的数。但由于方法 2 中提到的原因，我们只需要从 (i+(len−1)/2,j)\big(i+(len-1)/2,j\big)(i+(len−1)/2,j) 中选第一个数就可以了，其中 lenlenlen 是当前区间的长度。因此转移方程式为：

dp(i,j)=min⁡pivots(i+len−12,j)[pivot+max⁡(dp(i,pivot−1),dp(pivot+1,n))]\mathrm{dp}(i, j)=\min_{\mathrm{pivots}\big(i+\frac{len-1}{2}, j\big)}\big[\mathrm{pivot} + \max\big(\mathrm{dp}(i,\mathrm{pivot}-1), \mathrm{dp}(\mathrm{pivot}+1,n)\big)\big] dp(i,j)=pivots(i+2len−1​,j)min​[pivot+max(dp(i,pivot−1),dp(pivot+1,n))]

通过这种方法我们可以在一定程度上优化方法 3 。

public class Solution {
    public int getMoneyAmount(int n) {
        int[][] dp = new int[n + 1][n + 1];

        for (int len = 2; len <= n; len++) {
            for (int start = 1; start <= n - len + 1; start++) {
                int minres = Integer.MAX_VALUE;
                for (int piv = start + (len - 1) / 2; piv < start + len - 1; piv++) {
                    int res = piv + Math.max(dp[start][piv - 1], dp[piv + 1][start + len - 1]);
                    minres = Math.min(res, minres);
                }
                dp[start][start + len - 1] = minres;
            }

        }
        return dp[1][n];
    }
}

复杂度分析

    时间复杂度： O(n3)O(n^3)O(n3) 。我们遍历整个 dpdpdp 矩阵一次需要 O(n2)O(n^2)O(n2) 的时间。对于数组中每个元素，我们最多需要遍历 n2\frac{n}{2}2n​ 个元素。

    空间复杂度： O(n2)O(n^2)O(n2) 。 dpdpdp 数组的空间开销为 n2n^2n2 。

作者：LeetCode
链接：https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/solution/cai-shu-zi-da-xiao-ii-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

1.为什么使用动态规划，不使用二分？

动态规划与二分的区别在哪里呢？
使用动态规划的好处在于我可以穷举所有的情况，对于这个题来说，就是指动态规划的方法可以把每一个数字都当作分割点，而二分只能把中间的数字当作分割点。
举个例子：
当n=5：

动态规划：1 2 3 4 5 在第一次猜数时，我们可以猜1,2,3,4,5
二分查找：1 2 3 4 5 在第一次猜数时，我们只能猜3

为什么要使用动态规划猜所有的数字呢？
当n=5，假如我第一次猜3，那么需要7；假如我第一次猜4，只需要6.
很显然6才是正确答案，使用二分法虽然方便，但是是错误的。所以我使用动态规划穷举所有情况。
2.对于二维数组dp[i][j]的理解

动态规划需要使用内存储存计算过的结果，在这里我使用一个二维数组dp[n+1][n+1]

对于动态规划来说，需要明白dp[i][j]的含义，所以接下来我尝试解释dp[i][j]的含义:
dp[i][j]是说依次以从i到j的数字作为分割点(猜的数)，必定赢的游戏所用钱的最小值。
这样看起来似乎很难理解。

(1)解释dp[1][1]:
dp[1][1]是指只有一个数字1，我们以1作为分割点(猜的数)，赢得游戏所用钱的最小值，一看就知道，dp[1][1]=0。因为我们只能猜1，答案也只能是1，不用花钱

(2)解释dp[1][2]:
dp[1][2]是指只有两个数字1，2
我们先以1作为分割点(猜的数):

猜1：    
答案是1，花费0元
答案是2，花费1元
必定赢得游戏，最多花费1元

我们再以2作为分割点(猜的数):

猜2：
答案是1，花费2元
答案是2，花费0元
必定赢得游戏，最多花费2元

综上，只要进入[1,2]这个区间，我们第一次猜1，只要花费1元，必定可以赢得游戏（假如看不懂，再看一次，细细的品）
所以dp[1][2]=1(只要花1元必定赢得游戏，当第一次猜1时)

(3)解释dp[2][3]:
dp[2][3]是指只有两个数字2，3

有一个小问题，为什么不是从1开始呢？(明白的不用看)
比如n=3，我们第一次猜了1，但是答案是2或者3，反正不是1，我们是不是要到[2,3]区间来寻找答案，即求
dp[2][3]

我们先以2作为分割点(猜的数):

猜2：    
答案是2，花费0元
答案是3，花费2元
必定赢得游戏，最多花费2元

我们再以3作为分割点(猜的数):

猜3：
答案是2，花费3元
答案是3，花费0元
必定赢得游戏，最多花费3元

综上，只要进入[2,3]这个区间，我们第一次猜2，只要花费2元，必定可以赢得游戏
所以dp[2][3]=2(只要花2元必定赢得游戏，当第一次猜2时)

(4)解释dp[1][3]:
dp[1][3]是指只有三个数字1，2，3
我们先以1作为分割点(猜的数):

猜1：
答案是1，花费0元
答案是2或者3，这个时候会进入另一个区间[2,3]，花费1+dp[2][3]元
必定赢得游戏，最多花费max(0,1+dp[2][3])元

我们再以2作为分割点(猜的数):

猜2：
答案是1，花费2+dp[1][1]=2+0=2元
答案是2，花费0元
答案是3，花费2+dp[3][3]=2+0=2元
必定赢得游戏，最多花费max(0,2+dp[1][1],2+dp[3][3])元

我们最后以3作为分割点(猜的数):

猜3：
答案是1或者2,花费3+dp[1][2]元
答案是3，花费0元
必定赢得游戏，最多花费max(0,3+dp[1][2])元

综上，只要进入[1][3]这个区间，我们只要花费min( max(0,1+dp[2][3]) , max(0,2+dp[1][1],2+dp[3][3]) , max(0,3+dp[1][2]) )元必定可以赢的游戏
而dp[1][3]也就等于那个min的值。

可以发现，只要找到dp[1][n]即可。
(假如不能明白dp[i][j]可以返回上面内容看例子，明白后再往下阅读)
3.状态转移方程

状态转移方程怎么写呢？
看第4个例子，dp[1][3]我们就可以发现：
对于每一个分割点，我们取它左右两边区间的最大值加上分割点本身作为取此分割点的dp[i][j]值
对于每一个区间，我们取所有分割点的dp[i][j]的最小值作为dp[i][j]的真正的值
特别地，对于以i作为分割点的dp[i][j]，只取i右边的区间；对于以j作为分割点的dp[i][j]，只取j左边的区间

这个我觉得看懂dp[1][3]不难理解，要是理解不了的话，我这样解释一下(明白的不用看)：

i i+1 i+2 ... ... j-2 j-1 j
以i+1为分割点对应的：dp1=max(dp[i][i],dp[i+2][j])+i+1
以j-1为分割点对应的: dp2=max(dp[i][j-2],dp[j][j])+j-1
特别地,以i为分割点：dp0=i+dp[i+1][j];以j为分割点: dp3=j+dp[i][j-1]
dp[i][j]=min(dp0,dp1,dp2,dp3)

4.数组填充

给出一个dp二维数组来用代码填充它，“\”表示正无穷

(1)初始化：         (2)易知dp[i][i]=0   
| \ \ \ \ |         | 0 \ \ \ |
| \ \ \ \ |         | \ 0 \ \ |
| \ \ \ \ |         | \ \ 0 \ |
| \ \ \ \ |         | \ \ \ 0 |

接下来要考虑怎么填充矩阵以得到dp[1][n]:
很容易我们发现可以用一个位置左边和下边地数据来计算它本身，因此可以这样填充

(3)填充1列：
| 0 1 \ \ |  dp[1][2]计算步骤向上看
| \ 0 \ \ |
| \ \ 0 \ |
| \ \ \ 0 |
(4)再填充1列：
| 0 1 x \ |  dp[1][3]计算步骤向上看
| \ 0 2 \ |  dp[2][3]计算步骤向上看(先填充)
| \ \ 0 \ |
| \ \ \ 0 |
(5)再填充最后一列:
| 0 1 x x |  dp[1][4]计算步骤向上看
| \ 0 2 x |  dp[2][4]计算步骤向上看(然后填充)
| \ \ 0 x |  dp[3][4]计算步骤向上看(先填充)
| \ \ \ 0 |
x都是因为我懒得算了... ... 偷个懒，有兴趣可以自己算

5.代码实现

上述问题搞清楚就可以来写代码了

class Solution {
public:
    int getMoneyAmount(int n) {
        if(n==1)
            return 0;
        //定义矩阵
        int dp[n+1][n+1];
        //初始化“\”
        for(int i=0;i<=n;i++){
            for(int j=0;j<=n;j++){
                dp[i][j]=INT_MAX;
            }
        }
        //定义基础值dp[i][i]
        for(int i=0;i<=n;i++){
            dp[i][i]=0;
        }

        //按列来，从第2列开始
        for(int j=2;j<=n;j++){
            //按行来，从下往上
            for(int i=j-1;i>=1;i--){
                //算除了两端的每一个分割点
                for(int k=i+1;k<=j-1;k++){
                    dp[i][j]=min(k+max(dp[i][k-1],dp[k+1][j]),dp[i][j]);
                }
                //算两端
                dp[i][j]=min(dp[i][j],i+dp[i+1][j]);
                dp[i][j]=min(dp[i][j],j+dp[i][j-1]);
            }
        }
        return dp[1][n];
    }
};

作者：smilyt_
链接：https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/solution/dong-tai-gui-hua-c-you-tu-jie-by-zhang-xiao-tong-2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
