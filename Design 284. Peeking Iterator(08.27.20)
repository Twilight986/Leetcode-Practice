Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that support the peek() operation -- it essentially peek() at the element that will be returned by the next call to next().

Example:

Assume that the iterator is initialized to the beginning of the list: [1,2,3].

Call next() gets you 1, the first element in the list.
Now you call peek() and it returns 2, the next element. Calling next() after that still return 2. 
You call next() the final time and it returns 3, the last element. 
Calling hasNext() after that should return false.

Follow up: How would you extend your design to be generic and work with all types, not just integer?


评价：medium

参考讲解：
解法一 队列

    将IteratorIteratorIterator所指向的所有元素放到一个队列LinkedListLinkedListLinkedList中；
    然后LinkedListLinkedListLinkedList的peekpeekpeek方法就是题目要求的peek，pollpeek，pollpeek，poll方法就是题目要求的next，hasNextnext，hasNextnext，hasNext可以通过!queue.isEmpty()!queue.isEmpty()!queue.isEmpty()判断队列即可。

 class PeekingIterator implements Iterator<Integer> {

        private LinkedList<Integer> queue;

        public PeekingIterator(Iterator<Integer> iterator) {
            queue = new LinkedList<>();
            while (iterator.hasNext()) {
                queue.add(iterator.next());
            }
        }

        public Integer peek() {
            return queue.peek();
        }

        @Override
        public Integer next() {
            return queue.poll();
        }

        @Override
        public boolean hasNext() {
            return !queue.isEmpty();
        }
    }

复杂度
时间复杂度：O(n)O(n)O(n)
空间复杂度：O(n)O(n)O(n)。因为多开辟了一个nnn大小的队列。
解法二 peek预取

详见代码

class PeekingIterator implements Iterator<Integer> {

        private Integer cur;
        private Iterator<Integer> iterator;

        public PeekingIterator(Iterator<Integer> iterator) {
            this.iterator = iterator;
            cur = null;
        }

        public Integer peek() {
            if (cur != null) {
                return cur;
            }

            cur = iterator.next();
            return cur;
        }

        @Override
        public Integer next() {
            if (cur != null) {
                int res = cur;
                cur = null;
                return res;
            }

            return iterator.next();
        }

        @Override
        public boolean hasNext() {
            return cur != null || iterator.hasNext();
        }
    }

复杂度
时间复杂度：O(n)O(n)O(n)
空间复杂度：O(1)O(1)O(1)

两种解法对比

    解法一通过javajavajava自带的LinkedListLinkedListLinkedList来实现，比较简单；但是解法一需要另外耗费n（元素个数）大小的空间
    解法二无需耗费额外空间，但是相对第一种解法代码更加啰嗦了一点。不过我还是推荐这种解法。

作者：yuruiyin
链接：https://leetcode-cn.com/problems/peeking-iterator/solution/java-liang-chong-jie-fa-by-npe_tle-3/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
