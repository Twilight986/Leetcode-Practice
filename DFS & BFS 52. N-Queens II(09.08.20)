The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.

Given an integer n, return the number of distinct solutions to the n-queens puzzle.

Example:

Input: 4
Output: 2
Explanation: There are two distinct solutions to the 4-queens puzzle as shown below.
[
 [".Q..",  // Solution 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // Solution 2
  "Q...",
  "...Q",
  ".Q.."]
]


我的答案：
class Solution {
    
    int[] dia1;
    int[] dia2;
    int[] rows;
    int n;
    
    public int totalNQueens(int n) {
        rows = new int[n];
        dia1 = new int[2 * n - 1];
        dia2 = new int[2 * n - 1];
        this.n = n;
        return backtrack(0, 0);
    }
    
    public int backtrack(int row, int count){
        if (row >= n) return count;
        for (int col = 0; col < n; col++){
            if (notUnderAttack(row, col)){
                place(row,col);
                if (row == n - 1) count++;
                count = backtrack(row + 1, count);
                remove(row, col);
            }
        }
        return count;
    }
    
    public boolean notUnderAttack(int row, int col){
        return (rows[col] + dia1[row - col + n - 1] + dia2[row + col]) == 0;
    }
    
    public void place(int row, int col){
        rows[col] = 1;
        dia1[row - col + n - 1] = 1;
        dia2[row + col] = 1;
    }
    
    public void remove(int row, int col){
        rows[col] = 0;
        dia1[row - col + n - 1] = 0;
        dia2[row + col] = 0;
    }
}

评价：hard

参考讲解：
直观想法

这个问题是一个经典的问题，感受解法的优雅性很重要。

第一个想法是使用蛮力法，意味着生成在棋盘上放置 N 个皇后的所有可能的情况，并且检查是否保证没有皇后可以互相攻击。这意味着 O(NN)\mathcal{O}(N^N)O(NN) 的时间复杂度，因此我们必须考虑优化。

下面是两个有用的编程概念。

    第一个叫做 约束编程.

它的基本含义是在放置每个皇后以后增加限制。当在棋盘上放置了一个皇后后，立即排除当前行，列和对应的两个对角线。该过程传递了 约束 从而有助于减少需要考虑情况数。

51_pic.png

    第二个叫做 回溯法.

我们来想象一下，当在棋盘上放置了几个皇后且不会相互攻击。但是选择的方案不是最优的，因为无法放置下一个皇后。此时我们该怎么做？回溯。意思是回退一步，来改变最后放置皇后的位置并且接着往下放置。如果还是不行，再 回溯。
51_backtracking_.png



方法1：回溯

在建立算法之前，我们来考虑两个有用的细节。

    一行只可能有一个皇后且一列也只可能有一个皇后。

这意味着没有必要再棋盘上考虑所有的方格。只需要按列循环即可。

    对于所有的主对角线有 行号 + 列号 = 常数，对于所有的次对角线有 行号 - 列号 = 常数.

这可以让我们标记已经在攻击范围下的对角线并且检查一个方格 (行号, 列号) 是否处在攻击位置。

51_diagonals.png

现在已经可以写回溯函数 backtrack(row = 0).

    从第一个 row = 0 开始.

    循环列并且试图在每个 column 中放置皇后.

        如果方格 (row, column) 不在攻击范围内
            在 (row, column) 方格上放置皇后。
            排除对应行，列和两个对角线的位置。
            If 所有的行被考虑过，row == N
                意味着我们找到了一个解
            Else
                继续考虑接下来的皇后放置 backtrack(row + 1).
            回溯：将在 (row, column) 方格的皇后移除.

下面是上述算法的一个直接的实现。

class Solution {
  public boolean is_not_under_attack(int row, int col, int n,
                                     int [] rows,
                                     int [] hills,
                                     int [] dales) {
    int res = rows[col] + hills[row - col + 2 * n] + dales[row + col];
    return (res == 0) ? true : false;
  }

  public int backtrack(int row, int count, int n,
                       int [] rows,
                       int [] hills,
                       int [] dales) {
    for (int col = 0; col < n; col++) {
      if (is_not_under_attack(row, col, n, rows, hills, dales)) {
        // place_queen
        rows[col] = 1;
        hills[row - col + 2 * n] = 1;  // "hill" diagonals
        dales[row + col] = 1;   //"dale" diagonals    

        // if n queens are already placed
        if (row + 1 == n) count++;
        // if not proceed to place the rest
        else count = backtrack(row + 1, count, n,
                rows, hills, dales);

        // remove queen
        rows[col] = 0;
        hills[row - col + 2 * n] = 0;
        dales[row + col] = 0;
      }
    }
    return count;
  }

  public int totalNQueens(int n) {
    int rows[] = new int[n];
    // "hill" diagonals
    int hills[] = new int[4 * n - 1];
    // "dale" diagonals
    int dales[] = new int[2 * n - 1];

    return backtrack(0, 0, n, rows, hills, dales);
  }
}

复杂度分析

    时间复杂度：O(N!)\mathcal{O}(N!)O(N!). 放置第 1 个皇后有 N 种可能的方法，放置两个皇后的方法不超过 N (N - 2) ，放置 3 个皇后的方法不超过 N(N - 2)(N - 4) ，以此类推。总体上，时间复杂度为 O(N!)\mathcal{O}(N!)O(N!) .
    空间复杂度：O(N)\mathcal{O}(N)O(N) . 需要保存对角线和行的信息。



方法 2：使用 bitmap 回溯

如果你是在面试中 - 使用方法 1。

下面的算法有着相同的时间复杂度 O(N!)\mathcal{O}(N!)O(N!)。但是由于使用了位运算，可以运行得更快。

感谢这个算法的提出者 takaken.

为了便于理解该算法，下面的代码进行了逐步解释。

class Solution {
  public int backtrack(int row, int hills, int next_row, int dales, int count, int n) {
    /** 
     row: 当前放置皇后的行号
     hills: 主对角线占据情况 [1 = 被占据，0 = 未被占据]
     next_row: 下一行被占据的情况 [1 = 被占据，0 = 未被占据]
     dales: 次对角线占据情况 [1 = 被占据，0 = 未被占据]
     count: 所有可行解的个数
     */

    // 棋盘所有的列都可放置，
    // 即，按位表示为 n 个 '1'
    // bin(cols) = 0b1111 (n = 4), bin(cols) = 0b111 (n = 3)
    // [1 = 可放置]
    int columns = (1 << n) - 1;

    if (row == n)   // 如果已经放置了 n 个皇后
      count++;  // 累加可行解
    else {
      // 当前行可用的列
      // ! 表示 0 和 1 的含义对于变量 hills, next_row and dales的含义是相反的
      // [1 = 未被占据，0 = 被占据]
      int free_columns = columns & ~(hills | next_row | dales);

      // 找到可以放置下一个皇后的列
      while (free_columns != 0) {
        // free_columns 的第一个为 '1' 的位
        // 在该列我们放置当前皇后
        int curr_column = - free_columns & free_columns;

        // 放置皇后
        // 并且排除对应的列
        free_columns ^= curr_column;

        count = backtrack(row + 1,
                (hills | curr_column) << 1,
                next_row | curr_column,
                (dales | curr_column) >> 1,
                count, n);
      }
    }

    return count;
  }
  public int totalNQueens(int n) {
    return backtrack(0, 0, 0, 0, 0, n);
  }
}

复杂度分析

    时间复杂度：O(N!)\mathcal{O}(N!)O(N!).
    空间复杂度：O(N)\mathcal{O}(N)O(N).

作者：LeetCode
链接：https://leetcode-cn.com/problems/n-queens-ii/solution/nhuang-hou-ii-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
