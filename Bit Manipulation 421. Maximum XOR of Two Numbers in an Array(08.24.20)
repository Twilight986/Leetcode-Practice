Given a non-empty array of numbers, a0, a1, a2, … , an-1, where 0 ≤ ai < 231.

Find the maximum result of ai XOR aj, where 0 ≤ i, j < n.

Could you do this in O(n) runtime?

Example:

Input: [3, 10, 5, 25, 2, 8]

Output: 28

Explanation: The maximum result is 5 ^ 25 = 28.


我的答案：
class Solution {
    public int findMaximumXOR(int[] nums) {
        int maxNum = 0;
        for (int num : nums) maxNum = Math.max(maxNum, num);
        int len = (Integer.toBinaryString(maxNum)).length();
        int maxXor = 0;
        int mask = 0;
        for (int i = len - 1; i >= 0; i--){
            mask |= 1 << i;
            Set<Integer> perfixes = new HashSet<>();
            for (int num : nums) perfixes.add(num & mask);
            int temp = maxXor | (1 << i);
            for (int p : perfixes){
                if (perfixes.contains(p ^ temp)) {
                    maxXor = temp;
                    break;
                }
            }
        }
        return maxXor;
    }
}

评价：medium

参考讲解：

这个讲的不错：

异或运算的性质

解决这个问题，我们首先需要利用异或运算的一个性质：

    如果 a ^ b = c 成立，那么a ^ c = b 与 b ^ c = a 均成立。

即 如果有三个数，满足其中两个数的异或值等于另一个值，那么这三个数的顺序可以任意调换。

（说明：利用这条性质，可以不使用第 3 个变量而交换两个变量的值。）

    那么如何理解这个性质呢？因为异或运算其实就是 二进制下不进位的加法，你不妨自己举几个例子，在草稿纸上验证一下。

如何应用到本题？

这道题找最大值的思路是这样的：因为两两异或可以得到一个值，在所有的两两异或得到的值中，一定有一个最大值，我们推测这个最大值应该是什么样的？即根据“最大值”的存在性解题（一定存在）。在这里要强调一下：

    我们只用关心这个最大的异或值需要满足什么性质，进而推出这个最大值是什么，而不必关心这个异或值是由哪两个数得来的。

（上面这句话很重要，如果读者一开始看不明白下面的思考，不妨多看几遍我上面写的这句话。）

于是有如下思考：

1、二进制下，我们希望一个数尽可能大，即希望越高位上越能够出现“1”，这样这个数就是所求的最大数，这是贪心算法的思想。

2、于是，我们可以从最高位开始，到最低位，首先假设高位是 “1”，把这 n 个数全部遍历一遍，看看这一位是不是真的可以是“1”，否则这一位就得是“0”，判断的依据是上面“异或运算的性质”，即下面的第 3 点；

3、如果 a ^ b = max 成立 ，max 表示当前得到的“最大值”，那么一定有 max ^ b = a 成立。我们可以先假设当前数位上的值为 “1”，再把当前得到的数与这个 n 个数的 前缀（因为是从高位到低位看，所以称为“前缀”）进行异或运算，放在一个哈希表中，再依次把所有 前缀 与这个假设的“最大值”进行异或以后得到的结果放到哈希表里查询一下，如果查得到，就说明这个数位上可以是“1”，否则就只能是 0（看起来很晕，可以看代码理解）。

一种极端的情况是，这 n 个数在某一个数位上全部是 0 ，那么任意两个数异或以后都只能是 0，那么假设当前数位是 1 这件事情就不成立。

4、如何得到前缀，可以用掩码（mask），掩码可以进行如下构造，将掩码与原数依次进行 “与” 运算，就能得到前缀。

10000000000000000000000000000000
11000000000000000000000000000000
11100000000000000000000000000000
11110000000000000000000000000000
11111000000000000000000000000000
11111100000000000000000000000000
11111110000000000000000000000000
11111111000000000000000000000000
11111111100000000000000000000000
11111111110000000000000000000000
11111111111000000000000000000000
11111111111100000000000000000000
11111111111110000000000000000000
11111111111111000000000000000000
11111111111111100000000000000000
11111111111111110000000000000000
11111111111111111000000000000000
11111111111111111100000000000000
11111111111111111110000000000000
11111111111111111111000000000000
11111111111111111111100000000000
11111111111111111111110000000000
11111111111111111111111000000000
11111111111111111111111100000000
11111111111111111111111110000000
11111111111111111111111111000000
11111111111111111111111111100000
11111111111111111111111111110000
11111111111111111111111111111000
11111111111111111111111111111100
11111111111111111111111111111110
11111111111111111111111111111111

以题目中的数组 [3, 10, 5, 25, 2, 8] 为例，下面讲解这个最大的两两异或值是如何得到的，这里为了方便演示，只展示一个数二进制的低 8 位。

(温馨提示：下面的幻灯片中，有几页上有较多的文字，可能需要您停留一下，可以点击右下角的后退 “|◀” 或者前进 “▶|” 按钮控制幻灯片的播放。)

参考代码 1：

题目说数组的最大数小于 2 的 31 次方，所以二进制应该是 31 位，那么最外层的 for 循环只需要执行 31 次。

这里感谢 @coder233 指出原本代码中的问题。

import java.util.HashSet;
import java.util.Set;

public class Solution {

    // 先确定高位，再确定低位（有点贪心算法的意思），才能保证这道题的最大性质
    // 一位接着一位去确定这个数位的大小
    // 利用性质： a ^ b = c ，则 a ^ c = b，且 b ^ c = a

    public int findMaximumXOR(int[] nums) {
        int res = 0;
        int mask = 0;
        for (int i = 30; i >= 0; i--) {
            // 注意点1：注意保留前缀的方法，mask 是这样得来的
            // 用异或也是可以的 mask = mask ^ (1 << i);
            mask = mask | (1 << i);

            // System.out.println(Integer.toBinaryString(mask));
            Set<Integer> set = new HashSet<>();
            for (int num : nums) {
                // 注意点2：这里使用 & ，保留前缀的意思（从高位到低位）
                set.add(num & mask);
            }

            // 这里先假定第 n 位为 1 ，前 n-1 位 res 为之前迭代求得
            int temp = res | (1 << i);
            for (Integer prefix : set) {
                if (set.contains(prefix ^ temp)) {
                    res = temp;
                    break;
                }
            }
        }
        return res;
    }
}

复杂度分析：

    时间复杂度：O(N)O(N)O(N)，把整个数组看了 313131 次，即 O(31N)=O(N)O(31N) = O(N)O(31N)=O(N)。
    空间复杂度：O(n)O(n)O(n)，这里的 nnn 是哈希表的长度，具体长度是多少，与输入的规模、扩容策略、负载因子和冲突策略等有关。例如 Java 在 JDK 1.8 以后，当哈希值冲突的时候，先把冲突的元素放在单链表上，当冲突的键值大于 8 的时候，再转成红黑树。
    参考资料：《jdk8中HashMap的优化和底层内存的优化》。

作者：liweiwei1419
链接：https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/solution/li-yong-yi-huo-yun-suan-de-xing-zhi-tan-xin-suan-f/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


官方，文字讲得不错，代码反正我是没看懂
概述

题目要求 O(N)O(N)O(N) 时间复杂度，下面会讨论两种典型的 O(N)O(N)O(N) 复杂度解法。

    利用哈希集合存储按位前缀。
    利用字典树存储按位前缀。

这两种解法背后的思想是一样的，都是先将整数转化成二进制形式，再从最左侧的比特位开始逐一处理来构建最大异或值。两个方法的不同点在于采用了不同的数据结构来存储按位前缀。第一个方法在给定的测试集下执行速度更快，但第二种方法更加普适，更加简单。

基础知识

0 和任意比特 x 异或结果还是 x 本身。

0⊕x=x0 \oplus x = x 0⊕x=x

如果a，b两个值相同，异或结果为0

x⊕x=0x \oplus x = 0 x⊕x=0
方法一：利用哈希集合存储按位前缀

假定数组为 [3, 10, 5, 25, 2, 8]，首先将其中的整数转化成二进制形式：

3=(00011)23 = (00011)_23=(00011)2​

10=(01010)210 = (01010)_210=(01010)2​

5=(00101)25 = (00101)_25=(00101)2​

25=(11001)225 = (11001)_225=(11001)2​

2=(00010)22 = (00010)_22=(00010)2​

8=(01000)28 = (01000)_28=(01000)2​

为了简化按位前缀的计算，将所有数转化成二进制形式之后，需要在左边补 0 使得所有数对齐。最终所有数的长度都为 LLL，其中 LLL 为最大数的二进制长度。

之后我们就可以从最左侧的比特位开始构建最大异或值了，在 L=5L = 5L=5 的情况下，可能的最大异或值为 (11111)2(11111)_2(11111)2​。

    首先检查最左侧的比特位有可能使其为 1 嘛？（即 (1∗∗∗∗)2(1****)_2(1∗∗∗∗)2​ 这种形式）。

显然是可以的，只要将 25=(11001)225 = (11001)_225=(11001)2​ 和另一个最左侧比特位为 0 的数（2，3，5，8，10）异或就可以了，这时候就得到了 (1∗∗∗∗)2(1****)_2(1∗∗∗∗)2​。

    继续下一步，有可能使得最左侧两个比特位都为 1 嘛？（即 (11∗∗∗)2(11***)_2(11∗∗∗)2​ 这种形式）

这时候考虑所有长度为 2 的按位前缀，检查是否有 p1p_1p1​，p2p_2p2​ 这样的组合，使得 p1⊕p2==11p_1 \oplus p_2 == 11p1​⊕p2​==11。

3=(00∗∗∗)23 = (00***)_23=(00∗∗∗)2​

10=(01∗∗∗)210 = (01***)_210=(01∗∗∗)2​

5=(00∗∗∗)25 = (00***)_25=(00∗∗∗)2​

25=(11∗∗∗)225 = (11***)_225=(11∗∗∗)2​

2=(00∗∗∗)22 = (00***)_22=(00∗∗∗)2​

8=(01∗∗∗)28 = (01***)_28=(01∗∗∗)2​

显然在这个数组里面是有的，如 5=(00∗∗∗)25 = (00***)_25=(00∗∗∗)2​ 和 25=(11∗∗∗)225 = (11***)_225=(11∗∗∗)2​ 异或，或者 2=(00∗∗∗)22 = (00***)_22=(00∗∗∗)2​ 和 25=(11∗∗∗)225 = (11***)_225=(11∗∗∗)2​ 异或，又或者 3=(00∗∗∗)23 = (00***)_23=(00∗∗∗)2​ 和 25=(11∗∗∗)225 = (11***)_225=(11∗∗∗)2​ 异或。

按这种方式一比特一比特处理下去就可以得到最大异或值。在这过程中需要检查各种前缀的异或结果，但由于长度为 L−iL - iL−i 的前缀数量不会超过 2L−i2^{L - i}2L−i，因此判断第 iii 个比特位是否有可能为 1 最多需要执行 2L−i×2L−i2^{L - i} \times 2^{L - i}2L−i×2L−i 次操作。

算法

    首先计算数组中最大数的二进制长度 LLL。

    初始化 max_xor = 0。

    从 i=L−1i = L - 1i=L−1 遍历到 i=0i = 0i=0（代表着从最左侧的比特位 L−1L - 1L−1 遍历到最右侧的比特位 000）：

        将 max_xor 左移，释放出下一比特位的位置。

        初始化 curr_xor = max_xor | 1（即将 max_xor 最右侧的比特置为 1）。

        遍历 nums，计算出长度为 L−iL - iL−i 的所有可能的按位前缀。
            将长度为 L−iL - iL−i 的按位前缀加入哈希集合 prefixes，按位前缀的计算公式如下：num >> i。

        遍历所有可能的按位前缀，检查是否存在 p1，p2 使得 p1^p2 == curr_xor。比较简单的做法是检查每个 p，看 curr_xor^p 是否存在。如果存在，就将 max_xor 改为 curr_xor（即将 max_xor 最右侧的比特位改为 1）。如果不存在，max_xor 最右侧的比特位继续保持为 0。

    返回 max_xor。

class Solution {
  public int findMaximumXOR(int[] nums) {
    int maxNum = nums[0];
    for(int num : nums) maxNum = Math.max(maxNum, num);
    // length of max number in a binary representation
    int L = (Integer.toBinaryString(maxNum)).length();

    int maxXor = 0, currXor;
    Set<Integer> prefixes = new HashSet<>();
    for(int i = L - 1; i > -1; --i) {
      // go to the next bit by the left shift
      maxXor <<= 1;   //这里为什么只移动一位
      // set 1 in the smallest bit
      currXor = maxXor | 1;   //在最后加一个1是干什么
      prefixes.clear();
      // compute all possible prefixes 
      // of length (L - i) in binary representation
      for(int num: nums) prefixes.add(num >> i);
      // Update maxXor, if two of these prefixes could result in currXor.
      // Check if p1^p2 == currXor, i.e. p1 == currXor^p2.
      for(int p: prefixes) {
        if (prefixes.contains(currXor^p)) {
          maxXor = currXor;
          break;
        }
      }
    }
    return maxXor;
  }
}

复杂度分析

    时间复杂度：O(N)O(N)O(N)。计算按位前缀需要遍历 nums 数组，复杂度为 NNN，计算所有可能按位前缀的异或结果复杂度为 2L−i×2L−i2^{L - i} \times 2^{L - i}2L−i×2L−i。最终复杂度为 ∑i=0L−1(N+4L−i)=NL+43(4L−1)\sum_{i = 0}^{L - 1}{(N + 4^{L - i})} = NL + \frac{4}{3}(4^L - 1)∑i=0L−1​(N+4L−i)=NL+34​(4L−1)，即 O(N)O(N)O(N) 复杂度。

    空间复杂度：O(1)O(1)O(1)。最长的按位前缀长度为 LLL，同时 L=1+[log⁡2M]L = 1 + [\log_2 M]L=1+[log2​M]，其中 M 为 nums 中的最大数值。

方法二：逐位字典树

为什么哈希集合不适合用来存储按位前缀？

对于那些一定不能得到最终解的路径可以通过剪枝来舍弃，但是用哈希集合来存储按位前缀是没法做剪枝优化的。举个例子，两次异或操作之后为了得到 (11∗∗∗)2(11***)_2(11∗∗∗)2​，显然只能让 25 和 最左侧为 000000 前缀的数字（2，3， 5）组合。

3=(00011)23 = (00011)_23=(00011)2​

10=(01010)210 = (01010)_210=(01010)2​

5=(00101)25 = (00101)_25=(00101)2​

25=(11001)225 = (11001)_225=(11001)2​

2=(00010)22 = (00010)_22=(00010)2​

8=(01000)28 = (01000)_28=(01000)2​

因此，在计算第三位比特的时候，我们就没有必要计算所有可能的按位前缀组合了。光看前两位就知道一些组合已经不能得到最大异或值了。

3=(000∗∗)23 = (000**)_23=(000∗∗)2​

10=(010∗∗)210 = (010**)_210=(010∗∗)2​

5=(001∗∗)25 = (001**)_25=(001∗∗)2​

25=(110∗∗)225 = (110**)_225=(110∗∗)2​

2=(000∗∗)22 = (000**)_22=(000∗∗)2​

8=(010∗∗)28 = (010**)_28=(010∗∗)2​

为了方便剪枝，我们要采用一种类树的存储结构。

按位字典树：这是什么？怎么构建？

假设数组为 [3, 10, 5, 25, 2]，据此来构建按位字典树。

3=(00011)23 = (00011)_23=(00011)2​

10=(01010)210 = (01010)_210=(01010)2​

5=(00101)25 = (00101)_25=(00101)2​

25=(11001)225 = (11001)_225=(11001)2​

2=(00010)22 = (00010)_22=(00010)2​

fig

字典树中每条根节点到叶节点的路径都代表了 nums 中的一个整数（二进制形式），举个例子，0 -> 0 -> 0 -> 1 -> 1 表示 3。与之前的方法一样，所有二进制的长度都为 LLL，其中 $$L = 1 + [\log_2 M]$$，这里 M 为 nums 中的最大数值。显然字典树的深度也为 LLL，同时叶子节点也都在同一层。

字典树非常适合用来存储整数的二进制形式，例如存储 2（00010） 和 3（00011），其中 5 个比特位中有 4 个比特位都是相同的。字典树的构建方式也很简单，就是嵌套哈希表。在每一步，判断要增加的孩子节点（0，1）是否已经存在，如果存在就直接访问该孩子节点。如果不存在，需要先新增孩子节点再访问。

TrieNode trie = new TrieNode();
for (String num : strNums) {
  TrieNode node = trie;
  for (Character bit : num.toCharArray()) { 
    if (node.children.containsKey(bit)) {
      node = node.children.get(bit);
    } else {
      TrieNode newNode = new TrieNode();
      node.children.put(bit, newNode);
      node = newNode;
    }
  }  
}

字典树中给定数的最大异或值

为了最大化异或值，需要在每一步找到当前比特值的互补比特值。下图展示了 25 在每一步要怎么走才能得到最大异或值：

fig

实现方式也很简单：

    如果当前比特值存在互补比特值，访问具有互补比特值的孩子节点，并在异或值最右侧附加一个 1。

    如果不存在，直接访问具有当前比特值的孩子节点，并在异或值最右侧附加一个 0。

TrieNode trie = new TrieNode();
for (String num : strNums) {
  TrieNode xorNode = trie;
  int currXor = 0;
  for (Character bit : num.toCharArray()) {
    Character toggledBit = bit == '1' ? '0' : '1';
    if (xorNode.children.containsKey(toggledBit)) {
      currXor = (currXor << 1) | 1;
      xorNode = xorNode.children.get(toggledBit);
    } else {
      currXor = currXor << 1;
      xorNode = xorNode.children.get(bit);
    }
  }
}

算法

算法结构如下所示：

    在按位字典树中插入数字。

    找到插入数字在字典树中所能得到的最大异或值。

算法的具体实现如下所示：

    将所有数字转化成二进制形式。

    将数字的二进制形式加入字典树，同时计算该数字在字典树中所能得到的最大异或值。再用该数字的最大异或值尝试性更新 max_xor。

    返回 max_xor。

实现

class TrieNode {
  HashMap<Character, TrieNode> children = new HashMap<Character, TrieNode>();
  public TrieNode() {}
}

class Solution {
  public int findMaximumXOR(int[] nums) {
    // Compute length L of max number in a binary representation
    int maxNum = nums[0];
    for(int num : nums) maxNum = Math.max(maxNum, num);
    int L = (Integer.toBinaryString(maxNum)).length();

    // zero left-padding to ensure L bits for each number
    int n = nums.length, bitmask = 1 << L;
    String [] strNums = new String[n];
    for(int i = 0; i < n; ++i) {
      strNums[i] = Integer.toBinaryString(bitmask | nums[i]).substring(1);
    }

    TrieNode trie = new TrieNode();
    int maxXor = 0;
    for (String num : strNums) {
      TrieNode node = trie, xorNode = trie;
      int currXor = 0;
      for (Character bit : num.toCharArray()) {
        // insert new number in trie  
        if (node.children.containsKey(bit)) {
          node = node.children.get(bit);
        } else {
          TrieNode newNode = new TrieNode();
          node.children.put(bit, newNode);
          node = newNode;
        }

        // compute max xor of that new number 
        // with all previously inserted
        Character toggledBit = bit == '1' ? '0' : '1';
        if (xorNode.children.containsKey(toggledBit)) {
          currXor = (currXor << 1) | 1;  //从这里就看不懂了
          xorNode = xorNode.children.get(toggledBit);
        } else {
          currXor = currXor << 1;
          xorNode = xorNode.children.get(bit);
        }
      }
      maxXor = Math.max(maxXor, currXor);
    }

    return maxXor;
  }
}

复杂度分析

    时间复杂度：O(N)O(N)O(N)。在字典树插入一个数的时间复杂度为 O(L)O(L)O(L)，找到一个数的最大异或值时间复杂度也为 O(L)O(L)O(L)。其中 L=1+[log⁡2M]L = 1 + [\log_2 M]L=1+[log2​M]，M 为数组中的最大数值，这里可以当做一个常量。因此最终时间复杂度为 O(N)O(N)O(N)。

    空间复杂度：O(1)O(1)O(1)。维护字典树最多需要 O(2L)=O(M)O(2^L) = O(M)O(2L)=O(M) 的空间，但由于输入的限制，这里的 L 和 M 可以当做常数。

作者：LeetCode
链接：https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/solution/shu-zu-zhong-liang-ge-shu-de-zui-da-yi-huo-zhi-by-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
