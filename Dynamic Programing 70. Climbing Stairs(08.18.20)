You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

Example 1:

Input: 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps

Example 2:

Input: 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step

 

Constraints:

    1 <= n <= 45


我的答案：
class Solution {
    public int climbStairs(int n) {
        if (n <= 0){
            return 0;
        }
        if (n < 2){
            return 1;
        }
        int[] staps = new int[n + 1];
        staps[1] = 1;
        staps[2] = 2;
        for (int i = 3; i <= n; i++){
            staps[i] = staps[i - 1] + staps[i - 2];
        }
        return staps[n];
    }
}

评价：easy

Approach 1: Brute Force

Algorithm

In this brute force approach we take all possible step combinations i.e. 1 and 2, at every step. At every step we are calling the function climbStairsclimbStairsclimbStairs for step 111 and 222, and return the sum of returned values of both functions.

climbStairs(i,n)=(i+1,n)+climbStairs(i+2,n) climbStairs(i,n)=(i + 1, n) + climbStairs(i + 2, n) climbStairs(i,n)=(i+1,n)+climbStairs(i+2,n)

where iii defines the current step and nnn defines the destination step.

public class Solution {
    public int climbStairs(int n) {
        return climb_Stairs(0, n);
    }
    public int climb_Stairs(int i, int n) {
        if (i > n) {
            return 0;
        }
        if (i == n) {
            return 1;
        }
        return climb_Stairs(i + 1, n) + climb_Stairs(i + 2, n);
    }
}

Complexity Analysis

    Time complexity : O(2n)O(2^n)O(2n). Size of recursion tree will be 2n2^n2n.

    Recursion tree for n=5 would be like this: Use binary tree to see the process

    Climbing_Stairs

    Space complexity : O(n)O(n)O(n). The depth of the recursion tree can go upto nnn.

Approach 2: Recursion with Memoization

Algorithm

In the previous approach we are redundantly calculating the result for every step. Instead, we can store the result at each step in memomemomemo array and directly returning the result from the memo array whenever that function is called again.

In this way we are pruning recursion tree with the help of memomemomemo array and reducing the size of recursion tree upto nnn.

public class Solution {
    public int climbStairs(int n) {
        int memo[] = new int[n + 1];
        return climb_Stairs(0, n, memo);
    }
    public int climb_Stairs(int i, int n, int memo[]) {
        if (i > n) {
            return 0;
        }
        if (i == n) {
            return 1;
        }
        if (memo[i] > 0) {
            return memo[i];
        }
        memo[i] = climb_Stairs(i + 1, n, memo) + climb_Stairs(i + 2, n, memo);
        return memo[i];
    }
}

Approach 3: Dynamic Programming

Algorithm

As we can see this problem can be broken into subproblems, and it contains the optimal substructure property i.e. its optimal solution can be constructed efficiently from optimal solutions of its subproblems, we can use dynamic programming to solve this problem.

One can reach ithi^{th}ith step in one of the two ways:

    Taking a single step from (i−1)th(i-1)^{th}(i−1)th step.

    Taking a step of 222 from (i−2)th(i-2)^{th}(i−2)th step.

So, the total number of ways to reach ithi^{th}ith is equal to sum of ways of reaching (i−1)th(i-1)^{th}(i−1)th step and ways of reaching (i−2)th(i-2)^{th}(i−2)th step.

Let dp[i]dp[i]dp[i] denotes the number of ways to reach on ithi^{th}ith step:

dp[i]=dp[i−1]+dp[i−2] dp[i]=dp[i-1]+dp[i-2] dp[i]=dp[i−1]+dp[i−2]

方法二：矩阵快速幂

思路

以上的方法适用于 nnn 比较小的情况，在 nnn 变大之后，O(n)O(n)O(n) 的时间复杂度会让这个算法看起来有些捉襟见肘。我们可以用「矩阵快速幂」的方法来优化这个过程。

首先我们可以构建这样一个递推关系：

[1110][f(n)f(n−1)]=[f(n)+f(n−1)f(n)]=[f(n+1)f(n)]\left[ \begin{matrix} 1 & 1 \\ 1 & 0 \end{matrix} \right] \left[ \begin{matrix} f(n)\\ f(n - 1) \end{matrix} \right] = \left[ \begin{matrix} f(n) + f(n - 1)\\ f(n) \end{matrix} \right] = \left[ \begin{matrix} f(n + 1)\\ f(n) \end{matrix} \right] [11​10​][f(n)f(n−1)​]=[f(n)+f(n−1)f(n)​]=[f(n+1)f(n)​]

因此：

[f(n+1)f(n)]=[1110]n[f(1)f(0)]\left[ \begin{matrix} f(n + 1)\\ f(n) \end{matrix} \right] = \left[ \begin{matrix} 1 & 1 \\ 1 & 0 \end{matrix} \right] ^n \left[ \begin{matrix} f(1)\\ f(0) \end{matrix} \right] [f(n+1)f(n)​]=[11​10​]n[f(1)f(0)​]

令：

M=[1110]M = \left[ \begin{matrix} 1 & 1 \\ 1 & 0 \end{matrix} \right] M=[11​10​]

因此我们只要能快速计算矩阵 MMM 的 nnn 次幂，就可以得到 f(n)f(n)f(n) 的值。如果直接求取 MnM^nMn，时间复杂度是 O(n)O(n)O(n) 的，我们可以定义矩阵乘法，然后用快速幂算法来加速这里 MnM^nMn 的求取。

如何想到使用矩阵快速幂？

    如果一个问题可与转化为求解一个矩阵的 nnn 次方的形式，那么可以用快速幂来加速计算
    如果一个递归式形如 f(n)=∑i=1maif(n−i)f(n) = \sum_{i = 1}^{m} a_i f(n - i)f(n)=∑i=1m​ai​f(n−i)，即齐次线性递推式，我们就可以把数列的递推关系转化为矩阵的递推关系，即构造出一个矩阵的 nnn 次方乘以一个列向量得到一个列向量，这个列向量中包含我们要求的 f(n)f(n)f(n)。一般情况下，形如 f(n)=∑i=1maif(n−i)f(n) = \sum_{i = 1}^{m} a_i f(n - i)f(n)=∑i=1m​ai​f(n−i) 可以构造出这样的 m×mm \times mm×m 的矩阵：

[a1a2a3⋯am100⋯0010⋯0001⋯0⋮⋮⋮⋱⋮000⋯1]\left[ \begin{matrix} a_1 & a_2 & a_3 & \cdots & a_m \\ 1 & 0 & 0 & \cdots & 0 \\ 0 & 1 & 0 & \cdots & 0 \\ 0 & 0 & 1 & \cdots & 0 \\ \vdots & \vdots & \vdots & \ddots & \vdots \\ 0 & 0 & 0 & \cdots & 1 \\ \end{matrix} \right] ⎣⎢⎢⎢⎢⎢⎢⎢⎢⎡​a1​100⋮0​a2​010⋮0​a3​001⋮0​⋯⋯⋯⋯⋱⋯​am​000⋮1​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎤​

    那么遇到非齐次线性递推我们是不是就束手无策了呢？其实未必。有些时候我们可以把非齐次线性递推转化为其次线性递推，比如这样一个递推：

f(x)=(2x−6)c+f(x−1)+f(x−2)+f(x−3)f(x) = (2x-6)c + f(x - 1) + f(x - 2) + f(x - 3) f(x)=(2x−6)c+f(x−1)+f(x−2)+f(x−3)

我们可以做这样的变换：

f(x)+xc=[f(x−1)+(x−1)c]+[f(x−2)+(x−2)c]+[f(x−3)+(x−3)c]f(x) + xc = [f(x - 1) + (x - 1)c] + [f(x - 2) + (x - 2)c] + [f(x - 3) + (x - 3)c] f(x)+xc=[f(x−1)+(x−1)c]+[f(x−2)+(x−2)c]+[f(x−3)+(x−3)c]

令 g(x)=f(x)+xcg(x) = f(x) + xcg(x)=f(x)+xc，那么我们又得到了一个齐次线性递：

g(x)=g(x−1)+g(x−2)+g(x−3)g(x) = g(x - 1) + g(x - 2) + g(x - 3) g(x)=g(x−1)+g(x−2)+g(x−3)

于是就可以使用矩阵快速幂求解了。当然并不是所有非齐次线性都可以化成齐次线性，我们还是要具体问题具体分析。

    留两个思考题：

        你能把 f(x)=2f(x−1)+3f(x−2)+4cf(x) = 2f(x - 1) + 3f(x - 2) + 4cf(x)=2f(x−1)+3f(x−2)+4c 化成齐次线性递推吗？欢迎大家在评论区留言。
        如果一个非齐次线性递推可以转化成齐次线性递推，那么一般方法是什么？这个问题也欢迎大家在评论区总结。

代码

public class Solution {
   public int climbStairs(int n) {
       int[][] q = {{1, 1}, {1, 0}};
       int[][] res = pow(q, n);
       return res[0][0];
   }
   public int[][] pow(int[][] a, int n) {
       int[][] ret = {{1, 0}, {0, 1}};
       while (n > 0) {
           if ((n & 1) == 1) {
               ret = multiply(ret, a);
           }
           n >>= 1;
           a = multiply(a, a);
       }
       return ret;
   }
   public int[][] multiply(int[][] a, int[][] b) {
       int[][] c = new int[2][2];
       for (int i = 0; i < 2; i++) {
           for (int j = 0; j < 2; j++) {
               c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];
           }
       }
       return c;
   }
}

复杂度

    时间复杂度：同快速幂，O(log⁡n)O(\log n)O(logn)。
    空间复杂度：O(1)O(1)O(1)。

方法三：通项公式

思路

之前的方法我们已经讨论了 f(n)f(n)f(n) 是齐次线性递推，根据递推方程 f(n)=f(n−1)+f(n−2)f(n) = f(n - 1) + f(n - 2)f(n)=f(n−1)+f(n−2)，我们可以写出这样的特征方程：

x2=x+1x^2 = x + 1 x2=x+1

求得 x1=1+52x_1 = \frac{1+\sqrt{5}}{2}x1​=21+5
​​，x2=1−52x_2 = \frac{1-\sqrt{5}}{2}x2​=21−5
​​，设通解为 f(n)=c1x1n+c2x2nf(n) = c_1 x_1 ^n + c_2 x_2 ^ nf(n)=c1​x1n​+c2​x2n​，代入初始条件 f(1)=1f(1) = 1f(1)=1，f(2)=1f(2) = 1f(2)=1，得 c1=15c_1 = \frac{1}{\sqrt{5}}c1​=5
​1​，c2=−15c_2 = -\frac{1}{\sqrt{5}}c2​=−5

​1​，我们得到了这个递推数列的通项公式：

f(n)=15[(1+52)n−(1−52)n]f(n) = \frac{1}{\sqrt{5}}\left[ \left(\frac{1+\sqrt{5}}{2}\right)^{n} - \left(\frac{1-\sqrt{5}}{2}\right)^{n} \right] f(n)=5
​1​[(21+5
​​)n−(21−5

​​)n]

接着我们就可以通过这个公式直接求第 nnn 项了。

代码

public class Solution {
    public int climbStairs(int n) {
        double sqrt5 = Math.sqrt(5);
        double fibn = Math.pow((1 + sqrt5) / 2, n + 1) - Math.pow((1 - sqrt5) / 2, n + 1);
        return (int)(fibn / sqrt5);
    }
}

复杂度

    时间复杂度：O(log⁡n)O(\log n)O(logn)，pow 方法将会用去 O(log⁡n)O(\log n)O(logn) 的时间。
    空间复杂度：O(1)O(1)O(1)。

总结

这里形成的数列正好是斐波那契数列，答案要求的 f(n)f(n)f(n) 即是斐波那契数列的第 nnn 项（下标从 000 开始）。我们来总结一下斐波那契数列第 nnn 项的求解方法：

    nnn 比较小的时候，可以直接使用过递归法求解，不做任何记忆化操作，时间复杂度是 O(2n)O(2^n)O(2n)，存在很多冗余计算。
    一般情况下，我们使用「记忆化搜索」或者「迭代」的方法，实现这个转移方程，时间复杂度和空间复杂度都可以做到 O(n)O(n)O(n)。
    为了优化空间复杂度，我们可以不用保存 f(x−2)f(x - 2)f(x−2) 之前的项，我们只用三个变量来维护 f(x)f(x)f(x)、f(x−1)f(x - 1)f(x−1) 和 f(x−2)f(x - 2)f(x−2)，你可以理解成是把「滚动数组思想」应用在了动态规划中，也可以理解成是一种递推，这样把空间复杂度优化到了 O(1)O(1)O(1)。
    随着 nnn 的不断增大 O(n)O(n)O(n) 可能已经不能满足我们的需要了，我们可以用「矩阵快速幂」的方法把算法加速到 O(log⁡n)O(\log n)O(logn)。
    我们也可以把 nnn 代入斐波那契数列的通项公式计算结果，但是如果我们用浮点数计算来实现，可能会产生精度误差。

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/
