题目：
Compare two version numbers version1 and version2.
If version1 > version2 return 1; if version1 < version2 return -1;otherwise return 0.

You may assume that the version strings are non-empty and contain only digits and the . character.

The . character does not represent a decimal point and is used to separate number sequences.

For instance, 2.5 is not "two and a half" or "half way to version three", it is the fifth second-level revision of the second first-level revision.

You may assume the default revision number for each level of a version number to be 0. For example, version number 3.4 has a revision number of 3 and 4 for its first and second level revision number. Its third and fourth level revision number are both 0.

 

Example 1:

Input: version1 = "0.1", version2 = "1.1"
Output: -1

Example 2:

Input: version1 = "1.0.1", version2 = "1"
Output: 1

Example 3:

Input: version1 = "7.5.2.4", version2 = "7.5.3"
Output: -1

Example 4:

Input: version1 = "1.01", version2 = "1.001"
Output: 0
Explanation: Ignoring leading zeroes, both “01” and “001" represent the same number “1”

Example 5:

Input: version1 = "1.0", version2 = "1.0.0"
Output: 0
Explanation: The first version number does not have a third level revision number, which means its third level revision number is default to "0"

 

Note:

    Version strings are composed of numeric strings separated by dots . and this numeric strings may have leading zeroes.
    Version strings do not start or end with dots, and they will not be two consecutive dots.


我的答案：
class Solution {
    public int compareVersion(String version1, String version2) {
        int n1 = version1.length(), n2 = version2.length();
        int p1 = 0, p2 = 0;
        int i1, i2;
        Pair<Integer, Integer> pair;
        while (p1 < n1 || p2 < n2){
            pair = getSub(version1, n1, p1);
            i1 = pair.getKey();
            p1 = pair.getValue();
            
            pair = getSub(version2, n2, p2);
            i2 = pair.getKey();
            p2 = pair.getValue();
            
            if (i1 != i2){
                return (i1 > i2) ? 1 : -1;
            }
        }
        return 0;
    }
    
    public Pair<Integer, Integer> getSub(String version, int n, int p){
        if (p > n - 1) return new Pair(0, p);
        int i, p_end = p;
        while (p_end < n && version.charAt(p_end) != '.'){
            p_end++;
        }
        if (p_end != n - 1){
            i = Integer.parseInt(version.substring(p, p_end));
        }else {
            i = Integer.parseInt(version.substring(p_end, n));
        }
        p = p_end + 1;
        return new Pair(i, p);
    }
}

评价：medium
1. 主要是题目不太好理解，其实就是比较版本号谁更大
2. 用到了一个叫Pair的API，类似一种map，用来存储对应数据和指针
当一个函数返回两个值并且两个值都有重要意义时我们一般会用Map的key和value来表达，但是这样的话就需要两个键值对，用Map映射去做处理时，此时的key相当于value的一个描述或者引用，而具体的信息都保存在value中，我们可以通过key去获取对应的value。但是当key和value都保存具体信息时，我们就需要用到Pair对了。Pair对也是键值对的形式。
 具体的实现：
在javax.util包下，有一个简单Pair类可以直接调用，用法是直接通过构造函数将所吸引类型的Key和value存入，这个key和value没有任何的对应关系类型也是任意定的。
3. p_end永远不可能 == n - 1，这个自己画个图就能理解
还要注意最后的部分是多个digits的情况
双指针，一次遍历，常数空间

方法一有两个缺点：

    是两次遍历的解决方法。
    消耗线性空间。

我们能否实现一个只有一次遍历和消耗常数空间的解决方法呢？

其思想是在每个字符串上使用两个指针，跟踪每个数组的开始和结束。

这样，可以并行地沿着两个字符串移动，检索并比较相应的块。一旦两个字符串都被解析，比较也就完成了。

算法：

首先，我们定义了一个名为 get_next_chunk(version, n, p) 的函数，用于检索字符串中的下一个块。这个函数有三个参数：输入字符串 version，它的长度 n，以及指针 p 为要检索块的第一个字符。它在指针 p 和下一个点之间返回一个整数块。为了帮助迭代，返回的是下一个快的第一个字符的指针。下面是如何使用此函数解决问题的方法：

    指针 p1 和 p2 分别指向 version1 和 version2 的起始位置：p1=p2=0。
    并行遍历两个字符串。当 p1 < n1 or p2 < n2：
        使用 get_next_chunk 函数获取 version1 和 version2 的下一个块 i1 和 i2。
        比较 i1 和 i2。如果不相同，则返回 1 或 -1。
    如果到了这里，说明版本号相同，则返回 0。

下面实现 get_next_chunk(version, n, p) 函数：

    块的开头由指针 p 标记。如果 p 设置为字符串的结尾，则字符串解析完成。若要继续比较，则在添加 .0 返回。
    如果 p 不在字符串的末尾，则沿字符串移动指针 p_end 以查找块的结尾。
    返回块 version.substring(p, p_end)。
 复杂度分析

    时间复杂度：O(max⁡(N,M))\mathcal{O}(\max(N, M))O(max(N,M))。其中 NNN 和 MMM 指的是输入字符串的长度。
    空间复杂度：O(1)\mathcal{O}(1)O(1)，没有使用额外的数据结构

作者：LeetCode
链接：https://leetcode-cn.com/problems/compare-version-numbers/solution/bi-jiao-ban-ben-hao-by-leetcode/
