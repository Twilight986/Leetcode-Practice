题目：
Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

Example 1:

Given nums = [1,1,1,2,2,3],

Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.

It doesn't matter what you leave beyond the returned length.

Example 2:

Given nums = [0,0,1,1,1,1,2,3,3],

Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.

It doesn't matter what values are set beyond the returned length.

Clarification:

Confused why the returned value is an integer but your answer is an array?

Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.

Internally you can think of this:

// nums is passed in by reference. (i.e., without making a copy)
int len = removeDuplicates(nums);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i < len; i++) {
    print(nums[i]);
}

我的答案：
class Solution {
    public int removeDuplicates(int[] nums, int k) {
        if(nums == null) return 0;
        if(nums.length <= k) return nums.length;
        
        // 1.定义[0,index] 是修改后的满足要求的数组区间,这里已经把0 1 2 ...k- 1 ,共k个数 放进去了
        int index = k - 1;
        // 2.判断终止条件
        for(int i = k;i < nums.length;i++){
            // 3.指针移动条件
            if(nums[i] != nums[index-k+1]){
                index++;
                nums[index] = nums[i];
            }
        }
        // 4.判断返回值
        return index + 1;

/*
作者：liuchuan1992
链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/solution/shuang-zhi-zhen-zhi-tong-xiang-zhi-zhen-che-di-jie/
*/
    }
}

评价：medium
1. 这个题本身不难，有好几种解决方法，这一种时间复杂度比较小O(n)
2. 首先还是考虑各种例外情况并判断
3. 接下来对正常的数组进行分析
由于每种数都是有k个元素可以重复的，所以可以先从开头划分一个容量为k的数组，用index表示数组最后一个元素的索引，所以index = k-1，这个算作1我们的第一个指针
接下来创建第二个指针用来和前面的元素进行比较
比较的过程是，之前划分出来的数组的后面一个元素和划分数组中的第一个元素进行比较，如果相同，说明这种元素可以重复的次数已经超出允许范围了，这个元素我们要丢弃，所以指针i向后移动一次，但是index指针不变，因为还有继续比较这种元素
直到找到的元素和index中的元素不同，就将index指针向后移动一个并且将这个不重复的元素放进去，因为index + 1，所以我们划分出的区间也向后移动了一个位置
