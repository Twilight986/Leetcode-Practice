Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.

Your algorithm's runtime complexity must be in the order of O(log n).

If the target is not found in the array, return [-1, -1].

Example 1:

Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]

Example 2:

Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]

 

Constraints:

    0 <= nums.length <= 10^5
    -10^9 <= nums[i] <= 10^9
    nums is a non decreasing array.
    -10^9 <= target <= 10^9


我的答案：
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] result = new int[]{-1,-1};
        if (nums == null || nums.length == 0) return result;
        int first = findFirst(nums, target);
        if (first == -1) return result;
        else {
            result[0] = first;
            result[1] = findLast(nums, target);
        }
        return result;
    }
    
    public int findFirst(int[] nums, int target){
        int left = 0, right = nums.length - 1;
        while(left < right){
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) right = mid;
            else if (nums[mid] > target) right = mid - 1;
            else left = mid + 1;
        }
        return (left != nums.length && nums[left] != target) ? -1 : left;
    }
    
    public int findLast(int[] nums, int target){
        int left = 0, right = nums.length - 1;
        while(left <= right){
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) left = mid + 1;
            else if (nums[mid] > target) right = mid - 1;
            else left = mid + 1;
        }
        return right;
    }
}

评价：medium
int mid = left + (right - left) / 2;是为了防止right和left过大而导致(left + right)越界

参考讲解：
二分查找学习建议

重点在于理解思想和练习，不可以套模板。

    着眼于题目中给出的 单调性 去分析应该如何缩小区间，mid 位置值是一个尝试的值，如果 mid 不是，进而分析 mid 的左边和右边是否存在解；
    理解二分查找的思路，到底向左走还是向右走，应该具体问题具体分析；
    遇到结论错误和死循环，需要耐心调试；
    这里推荐题解 《写对二分查找不能靠模板，需要理解加练习 （附练习题，持续更新）》 中，作者全篇采用了 while(left < right) 的写法，表示在退出循环的时候区间 [left, right] 只剩下一个元素，作者 把区间始终分为 222 个部分，最终使得区间只剩下 111 个元素的思路 可以使得思考一些较难的二分查找问题的时候大大简化。对于这道题（第 34 题），用这个思路可以很大程度上减少讨论。相信是一定可以帮助到大家的。

题外话：labuladong 在这个网站上写了很多误导人的题解，本人夸大其词，自卖自夸在题解区都是罕见的，并且其有 抄袭劣迹，大家可以看看他的动态，从未在「力扣」上正面回答过问题：参考意见，希望大家不要盲目认同和肯定，看完他的题解以后再看看其他作者的题解，并且 公正地 给出自己的赞，鼓励那些原创作者和态度认真的作者，给后来的朋友们正确的引导。我看了太多同学被他的题解误导，才写一些类似「打假」的文章，希望能够得到支持。

请不要去理解他的题解中 while (left < right) 表示左闭右开区间这层含义，对于解题没有好处。把区间定义成左闭右开，是人为的定义，这种定义放在 滑动窗口 问题里是合适的。但是两边向中间走的双指针问题（就是这里的二分）是不恰当的，left 和 right 理应该同等对待。定义成左闭右开对于做其他二分查找问题没有帮助，甚至更容易出错。

一个诚信都有问题，且对自己讲解的知识都漠不关心，来力扣只是打广告的人，请大家不要再支持。否则对真正有水平的作者来说是不公平的，受损的还是大家。在网上查了一下，还是有人和我一样，质疑这样的作者，可以看 这里。

斗胆建议真正有水平的作者可以自信一点，把题解稍微写得通俗易懂一些，代码可读性强一些，相信大家都会看得到，才不至于让大家被 labuladong 这种误导人的题解给带偏。

在这里我将一点一点为大家介绍这道题的解法，和应该怎样思考边界问题。全篇采用 while(left <= right) 这种二分查找的写法，表示在退出循环的时候区间 [left, right] 为空。在这里只是向大家展示：只要我们的逻辑是完备的，足够细心，写对二分查找问题就不是一件困难的事情。这里再次向大家强调：二分查找不能靠模板来学习，应该理解思想，仔细分析，在面对新问题的时候才不至于被一些边界和死循环给绕晕。
第 1 部分：查找 target 出现的第 1 个位置

二分查找的基本用法是在一个有序数组里查找目标元素，具体是看看区间中间元素的值 nums[mid] 与 target 的大小关系。如果等于，就可以直接返回；如果严格大于，就往右边查找；如果严格小于，就往左边查找。就这 333 种情况，查找的顺序应该是先判断等于，然后再判断大于还是小于，这也符合人们的正常思维。

具体到当前「力扣」第 34 题，由于一个元素出现多次，在具体分类讨论的时候，就有一点细微差别。

（如果嫌下面文字多，可以直接看代码，都有注释。）

    如果当前看到的元素恰好等于 target，那么当前元素有可能是 target 出现的第 111 个位置，因为我们要找第 111 个位置，此时我们应该向左边继续查找；
    如果当前看到的元素严格大于 target，那么当前元素一定不是要找的 target 出现的第 111 个位置，第 111 个位置肯定出现在 mid 的 左边 ，因此就需要在 [left, mid] 区间里继续查找；
    如果当前看到的元素严格小于 target，那么当前元素一定不是要找的 target 出现的第 111 个位置，第 111 个位置肯定出现在 mid 的 右边 ，因此就需要在 [mid + 1, right] 区间里继续查找。

代码 1：

private int findFirstPosition(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            // ① 不可以直接返回，应该继续向左边找，即 [left, mid - 1] 区间里找
            right = mid - 1;
        } else if (nums[mid] < target) {
            // 应该继续向右边找，即 [mid + 1, right] 区间里找
            left = mid + 1;
        } else {
            // 此时 nums[mid] > target，应该继续向左边找，即 [left, mid - 1] 区间里找
            right = mid - 1;
        }
    }

    // 此时 left 和 right 的位置关系是 [right, left]，注意上面的 ①，此时 left 才是第 1 次元素出现的位置
    // 因此还需要特别做一次判断
    if (left != nums.length && nums[left] == target) {
        return left;
    }
    return -1;
}

解释：

    第 111 次出现的位置和最后 111 次出现的位置肯定都在数组里。因此，初始化的时候 left = 0 、 right = nums.length - 1；
    nums[mid] == target 的时候，在 [left, mid - 1] 区间里找，有没有可能 nums[mid] 就是第 111 次出现的位置，有可能，但不要紧，退出循环的时候 right 指针在左，left 在右。如果数组里存在 target，那么 left 一定位于 target 出现的第 111 个位置，请看下图。

image.png

还有一种特殊情况，当要查找的目标元素不存在的时，分两种情况：（1）target 很大，（2）target 很小：

    target 很大，还是上面的例子

image.png

    target 很小，还是上面的例子

image.png

以上特殊例子，解释了为什么在 while (left <= right) 退出循环以后，需要单独判断 left 是否越界，以及判断 nums[left] 是不是目标元素的原因。
第 2 部分：查找 target 出现的最后 1 个位置

直接看代码，前面的部分就不赘述了。

代码 2：

private int findLastPosition(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (nums[mid] == target) {
            // 只有这里不一样：不可以直接返回，应该继续向右边找，即 [mid + 1, right] 区间里找
            left = mid + 1;
        } else if (nums[mid] < target) {
            // 应该继续向右边找，即 [mid + 1, right] 区间里找
            left = mid + 1;
        } else {
            // 此时 nums[mid] > target，应该继续向左边找，即 [left, mid - 1] 区间里找
            right = mid - 1;
        }
    }
    // 由于 findFirstPosition 方法可以返回是否找到，这里无需单独再做判断
    return right;
}

为什么返回 right 解释如下图：

image.png

这里注意：无需讨论不存在的情况。这是因为先执行了 findFirstPosition() 方法，这个方法如果返回 −1-1−1，显然我们就知道数组里不存在目标元素，可以直接返回 [-1, -1]。

接下来，我们补上主调方法：

代码 3：

public int[] searchRange(int[] nums, int target) {
    if (nums == null || nums.length == 0) {
        return new int[]{-1, -1};
    }
    int firstPosition = findFirstPosition(nums, target);
    // 如果第 1 次出现的位置都找不到，肯定不存在最后 1 次出现的位置
    if (firstPosition == -1) {
        return new int[]{-1, -1};
    }
    int lastPosition = findLastPosition(nums, target);
    return new int[]{firstPosition, lastPosition};
}

完整代码

完整代码如下：

代码 4：

public class Solution {

    public int[] searchRange(int[] nums, int target) {
        if (nums == null || nums.length == 0) {
            return new int[]{-1, -1};
        }
        int firstPosition = findFirstPosition(nums, target);
        if (firstPosition == -1) {
            return new int[]{-1, -1};
        }
        int lastPosition = findLastPosition(nums, target);
        return new int[]{firstPosition, lastPosition};
    }


    private int findFirstPosition(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            if (nums[mid] == target) {
                // ① 不可以直接返回，应该继续向左边找，即 [left, mid - 1] 区间里找
                right = mid - 1;
            } else if (nums[mid] < target) {
                // 应该继续向右边找，即 [mid + 1, right] 区间里找
                left = mid + 1;
            } else {
                // 此时 nums[mid] > target，应该继续向左边找，即 [left, mid - 1] 区间里找
                right = mid - 1;
            }
        }

        // 此时 left 和 right 的位置关系是 [right, left]，注意上面的 ①，此时 left 才是第 1 次元素出现的位置
        // 因此还需要特别做一次判断
        if (left != nums.length && nums[left] == target) {
            return left;
        }
        return -1;
    }

    private int findLastPosition(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            if (nums[mid] == target) {
                // 只有这里不一样：不可以直接返回，应该继续向右边找，即 [mid + 1, right] 区间里找
                left = mid + 1;
            } else if (nums[mid] < target) {
                // 应该继续向右边找，即 [mid + 1, right] 区间里找
                left = mid + 1;
            } else {
                // 此时 nums[mid] > target，应该继续向左边找，即 [left, mid - 1] 区间里找
                right = mid - 1;
            }
        }
        // 由于 findFirstPosition 方法可以返回是否找到，这里无需单独再做判断
        return right;
    }
}

作者：yong-cai-gu-zi-xi
链接：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/da-jia-bu-yao-kan-labuladong-de-jie-fa-fei-chang-2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
