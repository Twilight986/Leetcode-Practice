Given an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.

You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.

Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.

For the last line of text, it should be left justified and no extra space is inserted between words.

Note:

    A word is defined as a character sequence consisting of non-space characters only.
    Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.
    The input array words contains at least one word.

Example 1:

Input:
words = ["This", "is", "an", "example", "of", "text", "justification."]
maxWidth = 16
Output:
[
   "This    is    an",
   "example  of text",
   "justification.  "
]

Example 2:

Input:
words = ["What","must","be","acknowledgment","shall","be"]
maxWidth = 16
Output:
[
  "What   must   be",
  "acknowledgment  ",
  "shall be        "
]
Explanation: Note that the last line is "shall be    " instead of "shall     be",
             because the last line must be left-justified instead of fully-justified.
             Note that the second line is also left-justified becase it contains only one word.

Example 3:

Input:
words = ["Science","is","what","we","understand","well","enough","to","explain",
         "to","a","computer.","Art","is","everything","else","we","do"]
maxWidth = 20
Output:
[
  "Science  is  what we",
  "understand      well",
  "enough to explain to",
  "a  computer.  Art is",
  "everything  else  we",
  "do                  "
]


我的答案：
class Solution {
    
    private String addBlank(int n){
        StringBuilder blank = new StringBuilder();
        for (int i = 0; i < n; i++) blank.append(" ");
        return blank.toString();
    }
    
    public List<String> fullJustify(String[] words, int maxWidth) {
        List<String> result = new ArrayList<>();
        List<String> row = new ArrayList<>();
        int currLength = 0;
        for (int i = 0; i < words.length; ){
            if ((currLength == 0 && words[i].length() <= maxWidth) || (currLength > 0 && currLength + 1 + words[i].length() <= maxWidth)){
                row.add(words[i]);
                if (currLength == 0) currLength += words[i].length();
                else currLength += words[i].length() + 1;
                i++;
            } else {
                int sub = maxWidth - currLength + row.size() - 1;
                if (row.size() == 1) {
                    String blank = addBlank(sub);
                    result.add(row.get(0) + blank);
                }else {
                    int ave = sub / (row.size() - 1);
                    int leave = sub - (ave * (row.size() - 1));
                    StringBuilder temp = new StringBuilder();
                    temp.append(row.get(0));
                    int k = 1;
                    for (int j = 0; j < leave; j++){
                        temp.append(addBlank(ave + 1) + row.get(k));
                        k++;
                    }
                    for (; k < row.size(); k++) temp.append(addBlank(ave) + row.get(k));
                    result.add(temp.toString());
                }
                row = new ArrayList<>();
                currLength = 0;  //注意这两项的初始化
            }  
        }
        StringBuilder temp = new StringBuilder();
        temp.append(row.get(0));
        for (int j = 1; j < row.size(); j++) temp.append(" " + row.get(j));
        temp.append(addBlank(maxWidth - currLength));
        result.add(temp.toString());
        return result;
    }
}

评价：hard

参考讲解：
public List<String> fullJustify(String[] words, int maxWidth) {
    List<String> ans = new ArrayList<>();
    //当前行单词已经占用的长度
    int currentLen = 0;
    //保存当前行的单词
    List<String> row = new ArrayList<>();
    //遍历每个单词
    for (int i = 0; i < words.length;) {
        //判断加入该单词是否超过最长长度
        //分了两种情况，一种情况是加入第一个单词，不需要多加 1
        //已经有单词的话，再加入单词，需要多加个空格，所以多加了 1
        if (currentLen == 0 && currentLen + words[i].length() <= maxWidth
            || currentLen > 0 && currentLen + 1 + words[i].length() <= maxWidth) {
            row.add(words[i]);
            if (currentLen == 0) {
                currentLen = currentLen + words[i].length();
            } else {
                currentLen = currentLen + 1 + words[i].length();
            }
            i++;
        //超过的最长长度，对 row 里边的单词进行处理
        } else {
            //计算有多少剩余，也就是总共的空格数，因为之前计算 currentLen 多算了一个空格，这里加回来
            int sub = maxWidth - currentLen + row.size() - 1;
            //如果只有一个单词，那么就直接单词加空格就可以
            if (row.size() == 1) {
                String blank = getStringBlank(sub);
                ans.add(row.get(0) + blank);
            } else {
                //用来保存当前行的结果
                StringBuilder temp = new StringBuilder();
                //将第一个单词加进来
                temp.append(row.get(0));
                //计算平均空格数
                int averageBlank = sub / (row.size() - 1);
                //如果除不尽，计算剩余空格数
                int missing = sub - averageBlank * (row.size() - 1);
                //前 missing 的空格数比平均空格数多 1
                String blank = getStringBlank(averageBlank + 1);
                int k = 1;
                for (int j = 0; j < missing; j++) {
                    temp.append(blank + row.get(k));
                    k++;
                }
                //剩下的空格数就是求得的平均空格数
                blank = getStringBlank(averageBlank);
                for (; k < row.size(); k++) {
                    temp.append(blank + row.get(k));
                }
                //将当前结果加入 
                ans.add(temp.toString());

            }
            //清空以及置零
            row = new ArrayList<>();
            currentLen = 0;

        }
    }
    //单独考虑最后一行，左对齐
    StringBuilder temp = new StringBuilder();
    temp.append(row.get(0));
    for (int i = 1; i < row.size(); i++) {
        temp.append(" " + row.get(i));
    }
    //剩余部分用空格补齐
    temp.append(getStringBlank(maxWidth - currentLen));
    //最后一行加入到结果中
    ans.add(temp.toString());
    return ans;
}
//得到 n 个空白
private String getStringBlank(int n) {
    StringBuilder str = new StringBuilder();
    for (int i = 0; i < n; i++) {
        str.append(" ");
    }
    return str.toString();
}


作者：windliang
链接：https://leetcode-cn.com/problems/text-justification/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-1-5/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
